var documenterSearchIndex = {"docs":
[{"location":"examples/sedov.html#Example-3:-Sedov-Blast","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"","category":"section"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"    <img src='../assets/sedov.png' alt='missing' width=\"50%\" height=\"50%\" /><br>","category":"page"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"The Sedov Blast was invented in 1940s as a mathematical model of nuclear explosion. The setup is very simple: initialize a large amount of energy concentrated in a small volume and see how it expands in all directions faster than speed of sound. One has a semi-analytical solution for this problem which you can find from Rankine-Hugeniot jump conditions. (The solution is not analaytic per se because you still need to solve an ODE numerically.) There is a nice book about the subject.","category":"page"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"module sedov\ninclude(\"../src/LagrangianVoronoi.jl\")\nusing .LagrangianVoronoi, WriteVTK, LinearAlgebra\nusing LaTeXStrings, DataFrames, CSV, Plots, Measures","category":"page"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"Define constant parameters. Changing them will alter the result and you will no longer get agreement with the reference. Use examples/reference/sedov.jl to generate a reference for different setup. An interesting aspect of the dynamics is that large density in the wake is followed by near vacuum around the ground zero. The adiabatic index gamma is connected to the peak density by","category":"page"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"fracrho_mathrmmaxrho_0 = fracgamma + 1gamma - 1`","category":"page"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"so for gamma = 14 and rho_0 = 1, the density near the blast wave will jump from 1 to 6.","category":"page"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"In the mathematical dream world, the process begins with a singularity of energy at t=0. But this is impossible to do numerically (and physically as well). Thus, we initially prescribe a small radius r_bomb of energy E_bomb. To be consistent with the analytical solution, we start our clock with t = t_bomb, where t_bomb is determined from a mathematical formula below.","category":"page"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"const rho0 = 1.0\nconst xlims = (-1.0, 1.0)\nconst ylims = (-1.0, 1.0)\nconst N = 50 # resolution\nconst dr = 1.0/N\nconst nframes = 100\nconst gamma = 1.4\nconst P0 = 1e-8 # the background pressure (should be close to 0)\nconst c0 = sqrt(gamma*P0/rho0)  # sound speed\nconst r_bomb = 0.05 # the initial blast radius\nconst E_bomb = 0.3 # yeild energy of the bomb\nconst t_bomb = sqrt(rho0/E_bomb*r_bomb^5) # the initial time of the simulation\nconst t_end = 1.0\nconst CFL = 0.1\nconst export_path = \"results/sedov\"\n\nfunction ic!(p::VoronoiPolygon)\n    p.rho = rho0\n    p.mass = p.rho*area(p)\n    p.P = P0\n    p.e = 0.5*norm_squared(p.v) + p.P/(p.rho*(gamma - 1.0))\nend","category":"page"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"This function detonates the bomb by assigning huge over-pressure to all cells withing the radius r_bomb.","category":"page"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"function detonate_bomb!(grid::VoronoiGrid)\n    A_bomb = 0.0\n    for p in grid.polygons\n        r = norm(p.x)\n        if r < r_bomb\n            A_bomb += area(p)\n        end\n    end\n    P_bomb = (gamma-1.0)*E_bomb/A_bomb\n    for p in grid.polygons\n        r = norm(p.x)\n        if r < r_bomb\n            p.P = P_bomb\n            p.e = 0.5*norm_squared(p.v) + p.P/(p.rho*(gamma - 1.0))\n        end\n    end\nend","category":"page"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"This time, we shall use variable time step. It should be smallest in the inital phase of the simulation when the blast travels at huge speed. For that reason, we include time global variable t and we shall write our own time-marching loop.","category":"page"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"mutable struct Simulation <: SimulationWorkspace\n    grid::GridNS\n    solver::PressureSolver\n    E::Float64\n    S::Float64\n    t::Float64\n    Simulation() = begin\n        domain = Rectangle(xlims = xlims, ylims = ylims)\n        grid = GridNS(domain, dr)\n        populate_hex!(grid, ic! = ic!)\n        detonate_bomb!(grid)\n        solver = PressureSolver(grid)\n        return new(grid, solver, 0.0, 0.0, t_bomb)\n    end\nend\n\nfunction step!(sim::Simulation)\n    v_shock = 0.4*sim.t^(-0.6)*(E_bomb/rho0)^0.2\n    dt = CFL*dr/(sqrt(6.0)*v_shock)\n    move!(sim.grid, dt)\n    ideal_eos!(sim.grid, gamma; Pmin = P0)\n    find_pressure!(sim.solver, dt)\n    pressure_step!(sim.grid, dt)\n    find_D!(sim.grid)\n    viscous_step!(sim.grid, dt)\n    find_dv!(sim.grid, dt)\n    relaxation_step!(sim.grid, dt)\n    sim.t += dt\n    return\nend","category":"page"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"Let us plot the total energy and entropy.","category":"page"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"function postproc!(sim::Simulation)\n    sim.E = 0.0\n    sim.S = 0.0\n    for p in sim.grid.polygons\n        sim.E += p.mass*p.e\n        sim.S += p.mass*log(abs(p.P/abs(p.rho)^gamma))\n    end\n    println(\"t = $(sim.t)\")\n    println(\"energy = $(sim.E)\")\n    println(\"entropy = $(sim.S)\")\n    println()\nend","category":"page"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"We write our own time-marching loop and handle the file export manually. Once the simulation ends, we plot the density profile along the radial line and compare with the refence solution.","category":"page"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"function main()\n    if !ispath(export_path)\n        mkpath(export_path)\n        @info \"created a new path: $(export_path)\"\n    end\n    pvd_c = paraview_collection(joinpath(export_path, \"cells.pvd\"))\n    pvd_p = paraview_collection(joinpath(export_path, \"points.pvd\"))\n    nframe = 0\n    sim = Simulation()\n    milestones = collect(range(t_end, t_bomb, nframes)) # save the data here\n    vtp_vars = (:rho, :v, :e, :P)\n    while sim.t < t_end\n        step!(sim)\n        if sim.t > milestones[end]\n            @show sim.t\n            postproc!(sim)\n            println()\n            filename= joinpath(export_path, \"cframe$(nframe).vtp\")\n            pvd_c[sim.t] = export_grid(sim.grid, filename, vtp_vars...)\n            filename= joinpath(export_path, \"pframe$(nframe).vtp\")\n            pvd_p[sim.t] = export_points(sim.grid, filename, vtp_vars...)\n            pop!(milestones)\n            nframe += 1\n        end\n    end\n    vtk_save(pvd_c)\n    vtk_save(pvd_p)\n    x = Float64[]\n    rho = Float64[]\n    for p in sim.grid.polygons\n        push!(x, norm(p.x))\n        push!(rho, p.rho)\n    end\n    csv_data = DataFrame(x=x, rho=rho)\n\tCSV.write(string(export_path, \"/linedata.csv\"), csv_data)\n    plotdata()\nend\n\nfunction plotdata()\n    csv_data = CSV.read(string(export_path, \"/linedata.csv\"), DataFrame)\n    csv_ref = CSV.read(\"reference/sedov.csv\", DataFrame)\n    plt = scatter(\n        csv_data.x,\n        csv_data.rho,\n        xlabel = L\"x\",\n        ylabel = L\"rho\",\n        label = \"density\",\n        color = :red,\n        markeralpha = 0.5,\n        bottom_margin = 5mm,\n        markersize = 1,\n        markerstrokewidth=0,\n    )\n    plot!(\n        plt,\n        csv_ref.r,\n        csv_ref.rho,\n        label = \"analytic\",\n        color = :blue,\n        linewidth = 2\n    )\n    savefig(plt, string(export_path, \"/density.pdf\"))\n    return\nend\n\n\nif abspath(PROGRAM_FILE) == @__FILE__\n    main()\nend\n\nend","category":"page"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"","category":"page"},{"location":"examples/sedov.html","page":"Example 3: Sedov Blast","title":"Example 3: Sedov Blast","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/triplepoint.html#Example-6:-Triple-point-problem","page":"Example 6: Triple-point problem","title":"Example 6: Triple-point problem","text":"","category":"section"},{"location":"examples/triplepoint.html","page":"Example 6: Triple-point problem","title":"Example 6: Triple-point problem","text":"    <img src='../assets/triplepoint.png' alt='missing' width=\"75%\" height=\"50%\" /><br>","category":"page"},{"location":"examples/triplepoint.html","page":"Example 6: Triple-point problem","title":"Example 6: Triple-point problem","text":"Triple point is a fancy benchmark which contains three separate gases with different properties. It is described in detail in this paper and is essentially a two-dimensional version of a Riemann Problem. Scientists like it just because it creates a very cool spiral.","category":"page"},{"location":"examples/triplepoint.html","page":"Example 6: Triple-point problem","title":"Example 6: Triple-point problem","text":"module triplepoint\n\ninclude(\"../src/LagrangianVoronoi.jl\")\nusing .LagrangianVoronoi, Polyester\n\n\nconst rho0 = 1.0\nconst xlims = (0.0, 7.0)\nconst ylims = (0.0, 3.0)\nconst dr = 1e-2\nconst nframes = 200\nconst CFL = 0.1\nconst v_char = 1.5\nconst dt = CFL*dr/v_char\nconst t_end = 3.0\nconst export_path = \"results/triplepoint\"","category":"page"},{"location":"examples/triplepoint.html","page":"Example 6: Triple-point problem","title":"Example 6: Triple-point problem","text":"This struct helps to reduce the number of constant variables. Numbers xmin, xmax, ymin, ymax specify the rectangle where the phase is located at t = 0.","category":"page"},{"location":"examples/triplepoint.html","page":"Example 6: Triple-point problem","title":"Example 6: Triple-point problem","text":"struct FluidPhase\n    label::Int      # phase label\n    rho::Float64    # initial density\n    P::Float64      # initial density\n    gamma::Float64  # adiabatic index\n    xmin::Float64\n    xmax::Float64\n    ymin::Float64\n    ymax::Float64\nend\nconst phase1 = FluidPhase(1, 1, 1, 1.5, 0, 1, 0, 3)\nconst phase2 = FluidPhase(2, 1, 0.1, 1.4, 1, 7, 0, 1.5)\nconst phase3 = FluidPhase(3, 0.125, 0.1, 1.5, 1, 7, 1.5, 3)\nconst fluidphases = [phase1, phase2, phase3]\n\nfunction ic!(p::VoronoiPolygon)\n    for fp in fluidphases\n        if (fp.xmin <= p.x[1] <= fp.xmax) && (fp.ymin <= p.x[2] <= fp.ymax)\n            p.phase = fp.label\n            p.rho = fp.rho\n            p.P = fp.P\n            p.e = p.P/(p.rho*(fp.gamma - 1.0))\n            p.mass = p.rho*area(p)\n        end\n    end\nend","category":"page"},{"location":"examples/triplepoint.html","page":"Example 6: Triple-point problem","title":"Example 6: Triple-point problem","text":"Let us define our custom equation of state, which is different for every fluid phase. The @batch macro from the Polyester package makes it run in parallel. It is approximately godzillion times faster than @threads.","category":"page"},{"location":"examples/triplepoint.html","page":"Example 6: Triple-point problem","title":"Example 6: Triple-point problem","text":"function multi_eos!(grid::VoronoiGrid)\n    @batch for p in grid.polygons\n        fp = fluidphases[p.phase]\n        p.rho = p.mass/area(p)\n        eps = p.e - 0.5*norm_squared(p.v)\n        p.P = (fp.gamma - 1.0)*p.rho*eps\n        p.c2 = fp.gamma*p.P/p.rho\n        if p.P <= 0.0\n            throw(\"there was a negative pressure\")\n        end\n    end\nend","category":"page"},{"location":"examples/triplepoint.html","page":"Example 6: Triple-point problem","title":"Example 6: Triple-point problem","text":"The rest of the script is just the standard procedure.","category":"page"},{"location":"examples/triplepoint.html","page":"Example 6: Triple-point problem","title":"Example 6: Triple-point problem","text":"mutable struct Simulation <: SimulationWorkspace\n    grid::GridNS\n    psolver::PressureSolver\n    msolver::MultiphaseSolver\n    E::Float64\n    S::Float64\n    E0::Float64\n    S0::Float64\n    quality::Float64\n    first_step::Bool\n    Simulation() = begin\n        domain = Rectangle(xlims = xlims, ylims = ylims)\n        grid = GridNS(domain, dr)\n        populate_hex!(grid, ic! = ic!)\n        psolver = PressureSolver(grid)\n        msolver = MultiphaseSolver(grid)\n    return new(grid, psolver, msolver, 0.0, 0.0, 0.0, 0.0, 0.0, true)\n    end\nend\n\nfunction step!(sim::Simulation, t::Float64)\n    move!(sim.grid, dt)\n    multi_eos!(sim.grid)\n    find_pressure!(sim.psolver, dt)\n    pressure_step!(sim.grid, dt)\n    find_D!(sim.grid)\n    viscous_step!(sim.grid, dt)\n    find_dv!(sim.grid, dt)\n    multiphase_projection!(sim.msolver)\n    relaxation_step!(sim.grid, dt)\n    return\nend\n\n\nfunction postproc!(sim::Simulation, t::Float64)\n    @show t\n    grid = sim.grid\n    sim.E = 0.0\n    sim.S = 0.0\n    sim.quality = Inf\n    for p in grid.polygons\n        fp = fluidphases[p.phase]\n        sim.E += p.mass*p.e\n        sim.S += p.mass*(log(abs(p.P)) - fp.gamma*log(abs(p.rho)))\n        sim.quality = min(sim.quality, p.quality)\n    end\n    if sim.first_step\n        sim.E0 = sim.E\n        sim.S0 = sim.S\n        sim.first_step = false\n    end\n    sim.E -= sim.E0\n    sim.S -= sim.S0\n    @show sim.E\n    @show sim.S\n    @show sim.quality\n    println()\n    return\nend\n\nfunction main()\n    sim = Simulation()\n    run!(sim, dt, t_end, step!;\n        postproc! = postproc!,\n        nframes = nframes,\n        path = export_path,\n        save_csv = false,\n        save_points = true,\n        save_grid = true,\n        vtp_vars = (:P, :v, :rho, :phase, :quality)\n    )\nend\n\nif abspath(PROGRAM_FILE) == @__FILE__\n    main()\nend\n\nend","category":"page"},{"location":"examples/triplepoint.html","page":"Example 6: Triple-point problem","title":"Example 6: Triple-point problem","text":"","category":"page"},{"location":"examples/triplepoint.html","page":"Example 6: Triple-point problem","title":"Example 6: Triple-point problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api.html#API-reference","page":"API Documentation","title":"API reference","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Modules = [LagrangianVoronoi]\nPages = [\n    \"celldefs.jl\",\n    \"diffusion.jl\",\n    \"fastvector.jl\",\n    \"fourier.jl\",\n    \"geometry.jl\",\n    \"IO.jl\",\n    \"iterators.jl\",\n    \"move.jl\",\n    \"movingls.jl\",\n    \"neighborlist.jl\",\n    \"polygon.jl\",\n    \"populate.jl\",\n    \"pressure.jl\",\n    \"relaxation.jl\",\n    \"simulation.jl\",\n    \"threadedvec.jl\",\n    \"voronoigrid.jl\"\n]","category":"page"},{"location":"api.html#Main.LagrangianVoronoi.PolygonNS","page":"API Documentation","title":"Main.LagrangianVoronoi.PolygonNS","text":"PolygonNS(; x::RealVector, kwargs...)\n\nPredefined Voronoi Polygon for Navier-Stokes equations. Mandatory keyword variable x is the position of the generating seed.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.LagrangianVoronoi.@fluid_variables-Tuple{}","page":"API Documentation","title":"Main.LagrangianVoronoi.@fluid_variables","text":"fluid_variables()\n\nA convenience macro for enriching the definition of PolygonNS by user-defined variables. See examples/doubleshear.jl for a tutorial how to use it.\n\n\n\n\n\n","category":"macro"},{"location":"api.html#Main.LagrangianVoronoi.bdary_friction!-Tuple{Main.LagrangianVoronoi.VoronoiGrid, Function, Float64}","page":"API Documentation","title":"Main.LagrangianVoronoi.bdary_friction!","text":"bdary_friction!(grid::VoronoiGrid, vDirichlet::Function, dt::Float64)\n\nApplies a viscous drag at boundaries. This is used for Dirichlet condition for velocity when the the velocity is tangent of the surface. It cannot be used for inflows or outflows. The function vDirichlet should accept a single argument x::RealVector and return a RealVector corresponding to the velocity of the boundary.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.find_D!-Tuple{Main.LagrangianVoronoi.VoronoiGrid}","page":"API Documentation","title":"Main.LagrangianVoronoi.find_D!","text":"find_D!(grid::VoronoiGrid)\n\nCompute the velocity deformation tensor  D = frac12(nabla v + nabla v^T) and assign it to every polygon.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.viscous_step!-Tuple{Main.LagrangianVoronoi.VoronoiGrid, Float64}","page":"API Documentation","title":"Main.LagrangianVoronoi.viscous_step!","text":"viscous_step!(grid::VoronoiGrid, dt::Float64; artificial_viscosity::Bool = true)\n\nApplies one forward viscous step of size dt to all Voronoi polygons. It assumes that the velocity deformation tensor is already computed using the find_D! function. It is also assumed that every polygon p has its dynamic viscosity p.mu assigned by the initial condition or otherwise. A keyword parameter controls whether Stone-Norman viscosity tensor is used to damp oscillations near shocks (yes by default).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.FastVector","page":"API Documentation","title":"Main.LagrangianVoronoi.FastVector","text":"FastVector{T} <: AbstractVector{T}\n\nA vector with preallocated memory than can only increase in size. Compared to normal vector, this improves the performance of mesh generation by about 50%. If this is already implemented somewhere, please let me know.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.LagrangianVoronoi.fourier_step!-Tuple{Main.LagrangianVoronoi.VoronoiGrid, Float64}","page":"API Documentation","title":"Main.LagrangianVoronoi.fourier_step!","text":"fourier_step!(grid::VoronoiGrid, dt::Float64)\n\nUpdate the energy of Voronoi polygon by Fourier heat conduction.  This assumes that every polygon p has its value of heat conductivity p.k assigned by the initial condition or otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.heat_from_bdary!-Tuple{Main.LagrangianVoronoi.VoronoiGrid, Float64, Function, Float64}","page":"API Documentation","title":"Main.LagrangianVoronoi.heat_from_bdary!","text":"heat_from_bdary!(grid::VoronoiGrid, dt::Float64, T_bc::Function)\n\nUpdate the internal energy of a Voronoi cell by considering heat flux from boundary. Function T_bc specifies the temperature at that boundary and should return NaN  to indicate adiabatic walls. This currently works only for ideal gas.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.ideal_temperature!-Tuple{Main.LagrangianVoronoi.VoronoiGrid}","page":"API Documentation","title":"Main.LagrangianVoronoi.ideal_temperature!","text":"ideal_temperature!(grid::VoronoiGrid)\n\nAssign temperature to every Voronoi polygon based on ideal gas law.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.MAT0","page":"API Documentation","title":"Main.LagrangianVoronoi.MAT0","text":"MAT0\n\nA static 2x2 zero matrix.\n\n\n\n\n\n","category":"constant"},{"location":"api.html#Main.LagrangianVoronoi.MAT1","page":"API Documentation","title":"Main.LagrangianVoronoi.MAT1","text":"MAT1\n\nA static 2x2 identity matrix.\n\n\n\n\n\n","category":"constant"},{"location":"api.html#Main.LagrangianVoronoi.VEC0","page":"API Documentation","title":"Main.LagrangianVoronoi.VEC0","text":"VEC0\n\nStatic zero vector. Equivalent to zero(RealVector).\n\n\n\n\n\n","category":"constant"},{"location":"api.html#Main.LagrangianVoronoi.VECNULL","page":"API Documentation","title":"Main.LagrangianVoronoi.VECNULL","text":"VECNULL\n\nUndefined vector.\n\n\n\n\n\n","category":"constant"},{"location":"api.html#Main.LagrangianVoronoi.VECX","page":"API Documentation","title":"Main.LagrangianVoronoi.VECX","text":"VECX\n\nStatic cartesian basis vector in the X direction. Equivalent to RealVector(1,0)\n\n\n\n\n\n","category":"constant"},{"location":"api.html#Main.LagrangianVoronoi.VECY","page":"API Documentation","title":"Main.LagrangianVoronoi.VECY","text":"VECY\n\nStatic cartesian basis vector in the Y direction. Equivalent to RealVector(0,1).\n\n\n\n\n\n","category":"constant"},{"location":"api.html#Main.LagrangianVoronoi.Edge","page":"API Documentation","title":"Main.LagrangianVoronoi.Edge","text":"Edge(v1::RealVector, v2::RealVector; label::Int = 0)\n\nEdge defined by two endpoints and a label which indicates the neighbor's index. Zero or negative indices are used for domain boundaries.  Edges are stack-allocated and immutable. \n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.LagrangianVoronoi.RealMatrix","page":"API Documentation","title":"Main.LagrangianVoronoi.RealMatrix","text":"RealMatrix(x11::Float64, x21::Float64, x12::Float64, x22::Float64)\n\nStatic Float64 matrix with 2x2 elements. Be warned that Julia has column-major ordering of elements!\n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.LagrangianVoronoi.RealVector","page":"API Documentation","title":"Main.LagrangianVoronoi.RealVector","text":"RealVector(x1::Float64, x2::Float64)\n\nStatic Float64 vector with 2 elements.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.LagrangianVoronoi.Rectangle","page":"API Documentation","title":"Main.LagrangianVoronoi.Rectangle","text":"Rectangle(xmin::RealVector, xmax::RealVector)\n\nA rectangle aligned with the coordinate system defined by bottomleft and topright corner. \n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.LagrangianVoronoi.UnitRectangle-Tuple{}","page":"API Documentation","title":"Main.LagrangianVoronoi.UnitRectangle","text":"UnitRectangle()\n\nThe unit rectange (0,1)x(0,1).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.area-Tuple{Main.LagrangianVoronoi.Rectangle}","page":"API Documentation","title":"Main.LagrangianVoronoi.area","text":"area(r::Rectangle)::Float64\n\nUnoriented area of a rectangle.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.cross2-Tuple{StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}","page":"API Documentation","title":"Main.LagrangianVoronoi.cross2","text":"function cross2(a::RealVector, b::RealVector)::Float64\n\nA cross product in 2d. Returns a scalar equal to the z component of the corresponding 3d cross product\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.isinside-Tuple{Main.LagrangianVoronoi.Rectangle, StaticArraysCore.SVector{2, Float64}}","page":"API Documentation","title":"Main.LagrangianVoronoi.isinside","text":"isinside(r::Rectangle, x::RealVector)::Bool\n\nReturn true iff x lies inside r.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.isnullvector-Tuple{StaticArraysCore.SVector{2, Float64}}","page":"API Documentation","title":"Main.LagrangianVoronoi.isnullvector","text":"isnullvector(x::RealVector)::Bool\n\nReturns true iff the vector is VECNULL.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.len-Tuple{Main.LagrangianVoronoi.Edge}","page":"API Documentation","title":"Main.LagrangianVoronoi.len","text":"len(e::Edge)::Float64\n\nReturn the length of an edge.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.midpoint-Tuple{Main.LagrangianVoronoi.Edge}","page":"API Documentation","title":"Main.LagrangianVoronoi.midpoint","text":"midpoint(e::Edge)::RealVector\n\nThe edge midpoint.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.midpoint-Tuple{StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}","page":"API Documentation","title":"Main.LagrangianVoronoi.midpoint","text":"midpoint(x::RealVector, y::RealVector)::RealVector\n\nMidpoint inbetween two points.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.norm_squared-Tuple{StaticArraysCore.SVector{2, Float64}}","page":"API Documentation","title":"Main.LagrangianVoronoi.norm_squared","text":"norm_squared(x::RealVector)::Float64\n\nThe squared norm of a vector. This is much faster than norm(x)^2.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.outer-Tuple{StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}","page":"API Documentation","title":"Main.LagrangianVoronoi.outer","text":"outer(x::RealVector, y::RealVector)::RealMatrix\n\nThe outer product of two vectors.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.verts-Tuple{Main.LagrangianVoronoi.Rectangle}","page":"API Documentation","title":"Main.LagrangianVoronoi.verts","text":"verts(r::Rectangle)::NTuple{4, RealVector}\n\nReturn the four vertices of a Rectangle in counter-clockwise order, starting with the bottomleft corner.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.export_grid-Tuple{Main.LagrangianVoronoi.VoronoiGrid, String, Vararg{Symbol}}","page":"API Documentation","title":"Main.LagrangianVoronoi.export_grid","text":"export_grid(grid::VoronoiGrid, filename::String, vars::Symbol...)\n\nExport grid to a vtk file. Append datasets specified by vars. Currently only numbers and vectors can be exported.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.export_points-Tuple{Main.LagrangianVoronoi.VoronoiGrid, String, Vararg{Symbol}}","page":"API Documentation","title":"Main.LagrangianVoronoi.export_points","text":"export_points(grid::VoronoiGrid, filename::String, vars::Symbol...)\n\nExport points to a vtk file as a cloud of particles. Append datasets specified by vars.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.boundaries-Tuple{T} where T<:Main.LagrangianVoronoi.VoronoiPolygon","page":"API Documentation","title":"Main.LagrangianVoronoi.boundaries","text":"boundaries(p::VoronoiPolygon)\n\nCreate an iterator through all edges of 'p' that lie on the boundary of the domain.  This can be used to implement boundary forces.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.neighbors-Union{Tuple{T}, Tuple{T, Main.LagrangianVoronoi.VoronoiGrid{T}}} where T<:Main.LagrangianVoronoi.VoronoiPolygon","page":"API Documentation","title":"Main.LagrangianVoronoi.neighbors","text":"neighbors(p::VoronoiPolygon, grid::VoronoiGrid)\n\nCreate an iterator through all Voronoi polygons that neighbor the polygon p.  Use it in a for loop to iterate through all triplets (q,e,y) where \n\nq = the neighboring polygon\ne = the edge connecting p and q\ny = the position of q as a neighbor of p (equivalent to q.x for non-periodic grids)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.move!-Tuple{Main.LagrangianVoronoi.VoronoiGrid, Float64}","page":"API Documentation","title":"Main.LagrangianVoronoi.move!","text":"move!(grid::VoronoiGrid, dt::Float64)\n\nUpdate the positions of all polygons, moving each by dt*(p.v + p.dv).  The function ensures that points will never escape the computational domain (this would lead to undefined behavior). If the grid is peridoic, points will be wrapped around automatically. The grid is remeshed after this update.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.CubicExpansion","page":"API Documentation","title":"Main.LagrangianVoronoi.CubicExpansion","text":"CubicExpansion\n\nStatic vector to store coefficients of a cubic Taylor expansion.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.LagrangianVoronoi.LinearExpansion","page":"API Documentation","title":"Main.LagrangianVoronoi.LinearExpansion","text":"LinearExpansion\n\nStatic vector to store coefficients of a linear Taylor expansion.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.LagrangianVoronoi.QuadraticExpansion","page":"API Documentation","title":"Main.LagrangianVoronoi.QuadraticExpansion","text":"QuadraticExpansion\n\nStatic vector to store coefficients of a quadratic Taylor expansion.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.LagrangianVoronoi.integral-Tuple{Main.LagrangianVoronoi.VoronoiPolygon, Float64, StaticArraysCore.SVector{2, Float64}}","page":"API Documentation","title":"Main.LagrangianVoronoi.integral","text":"integral(p::VoronoiPolygon, val::Float64, taylor::SVector)::Float64\n\nCompute an integral of a polynomial over polygon p defined by value val at p.x and the  Taylor expansion taylor.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.movingls-Union{Tuple{T}, Tuple{Type{T}, Main.LagrangianVoronoi.VoronoiGrid, Main.LagrangianVoronoi.VoronoiPolygon, Function}} where T<:(StaticArraysCore.SVector)","page":"API Documentation","title":"Main.LagrangianVoronoi.movingls","text":"movingls(::Type{T}, grid::VoronoiGrid, p::VoronoiPolygon, fun; h,  kernel)\n\nFinds the Taylor expansion of a given function using moving least squares.  The first argument T should be one of following:\n\nLinearExpansion\nQuadraticExpansion\nCubicExpansion\n\nPolygon p is where the Taylor expansion of a function fun is computed. A keyword argument h is the moving radius. This needs to be sufficiently big, otherwise the Taylor expension may be undefined. Kernel is the weighting function used for defining the (weighted) least squared problem.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.point_value-Tuple{Main.LagrangianVoronoi.VoronoiGrid, StaticArraysCore.SVector{2, Float64}, Function}","page":"API Documentation","title":"Main.LagrangianVoronoi.point_value","text":"point_value(grid::VoronoiGrid, x::RealVector, fun::Function)\n\nObtain the interpolation of a function fun defined on polygons at an arbitrary point x. This is a slow code and should never be used in perfomance-critical areas.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.poly_eval-Union{Tuple{T}, Tuple{Float64, T, StaticArraysCore.SVector{2, Float64}}} where T<:(StaticArraysCore.SVector)","page":"API Documentation","title":"Main.LagrangianVoronoi.poly_eval","text":"poly_eval(val::Float64, taylor::T, dx::RealVector)::Float64 where {T <: SVector}\n\nUse this function to interpolate a value from the known Taylor expansion.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.VoronoiPolygon","page":"API Documentation","title":"Main.LagrangianVoronoi.VoronoiPolygon","text":"VoronoiPolygon\n\nAbstract supertype for Voronoi Polygons. We call them Voronoi Polygons and not Voronoi cells to avoid confusion with cells of a cell list. No functions need to be defined for subtypes of Voronoi Polygon but we require that it has these fields\n\nx::RealVector\nedges::FastVector{Edge}\n\nwhere x is the generating seed and edges is a list of all edges in no particular order. The edges can be  initialized as edges = emptypolygon() and are generated by the remesh! function.  The subtypes may contain additional fields depending on the physics involved. See src/celldefs.jl for examples. \n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.LagrangianVoronoi.area-Tuple{Main.LagrangianVoronoi.VoronoiPolygon}","page":"API Documentation","title":"Main.LagrangianVoronoi.area","text":"area(p::VoronoiPolygon)::Float64\n\nReturn the unoriented area of a polygon.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.centroid-Tuple{Main.LagrangianVoronoi.VoronoiPolygon}","page":"API Documentation","title":"Main.LagrangianVoronoi.centroid","text":"centroid(p::VoronoiPolygon)::RealVector\n\nReturn the centroid of a Voronoi polygon.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.is_inside-Tuple{Main.LagrangianVoronoi.VoronoiPolygon, StaticArraysCore.SVector{2, Float64}}","page":"API Documentation","title":"Main.LagrangianVoronoi.is_inside","text":"is_inside(p::VoronoiPolygon, x::RealVector)::Bool\n\nDetermine whether a point x lies inside the polygon p.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.isboundary-Tuple{Main.LagrangianVoronoi.Edge}","page":"API Documentation","title":"Main.LagrangianVoronoi.isboundary","text":"isboundary(e::Edge)::Bool\n\nReturn true iff edge e lies on domain boundary.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.isboundary-Tuple{Main.LagrangianVoronoi.VoronoiPolygon}","page":"API Documentation","title":"Main.LagrangianVoronoi.isboundary","text":"isboundary(p::VoronoiPolygon)::Bool\n\nReturn true iff the Voronoi Polygon has at least one edge on domain boundary.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.lr_ratio-Tuple{StaticArraysCore.SVector{2, Float64}, Main.LagrangianVoronoi.Edge}","page":"API Documentation","title":"Main.LagrangianVoronoi.lr_ratio","text":"lr_ratio(dx::RealVector, e::Edge)::Float64\n\nThe ratio between the length of a vector dx and length of the edge e.  This may sound like a dubious function but is used so very often in this method. It is slightly faster than norm(dx)/len(e) because it computes only one square root.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.normal_vector-Tuple{Main.LagrangianVoronoi.Edge}","page":"API Documentation","title":"Main.LagrangianVoronoi.normal_vector","text":"normal_vector(e::Edge)::RealVector\n\nThe vector is rotated by 90% counter-clockwise with respect to the edge e pointing from e.v1 to e.v2.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.surface_element-Tuple{Main.LagrangianVoronoi.VoronoiPolygon}","page":"API Documentation","title":"Main.LagrangianVoronoi.surface_element","text":"surface_element(p::VoronoiPolygon)::Float64\n\nThe net surface element of a Voronoi Polygon. The resulting vector points outward and is zero for interior polygons.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.tri_area-Tuple{StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}","page":"API Documentation","title":"Main.LagrangianVoronoi.tri_area","text":"tri_area(a::RealVector, b::RealVector, c::RealVector)::Float64\n\nReturn the unsigned area of a triangle given by three points. The points can be in arbitrary order.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.populate_circ!-Union{Tuple{Main.LagrangianVoronoi.VoronoiGrid{T}}, Tuple{T}} where T<:Main.LagrangianVoronoi.VoronoiPolygon","page":"API Documentation","title":"Main.LagrangianVoronoi.populate_circ!","text":"populate_circ!(grid::VoronoiGrid{T}; charfun, center, ic!)\n\nPopulate computational domain with polygons arranged in concentric circles.  Keyword parameters:\n\ncharfun: the characteristic function; only those areas where charfun(x) = true are populated\ncenter: the center of each circle\nic!: the initial condition; ic!(p) is called on every polygon after the mesh is generated\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.populate_hex!-Union{Tuple{Main.LagrangianVoronoi.VoronoiGrid{T}}, Tuple{T}} where T<:Main.LagrangianVoronoi.VoronoiPolygon","page":"API Documentation","title":"Main.LagrangianVoronoi.populate_hex!","text":"populate_hex!(grid::VoronoiGrid{T}; charfun, ic!)\n\nPopulate computational domain with polygons arranged in hexagonal grid. Use this initializing method when you are not sure. Keyword parameters:\n\ncharfun: the characteristic function; only those areas where charfun(x) = true are populated\nic!: the initial condition; ic!(p) is called on every polygon after the mesh is generated\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.populate_lloyd!-Union{Tuple{Main.LagrangianVoronoi.VoronoiGrid{T}}, Tuple{T}} where T<:Main.LagrangianVoronoi.VoronoiPolygon","page":"API Documentation","title":"Main.LagrangianVoronoi.populate_lloyd!","text":"populate_lloyd!(grid::VoronoiGrid{T}; charfun, niterations, ic!)\n\nPopulate computational domain with polygons arranged in concentric circles.  Keyword parameters:\n\ncharfun: the characteristic function; only those areas where charfun(x) = true are populated\ncenter: the center of each circle\nic!: the initial condition; ic!(p) is called on every polygon after the mesh is generated\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.populate_rand!-Union{Tuple{Main.LagrangianVoronoi.VoronoiGrid{T}}, Tuple{T}} where T<:Main.LagrangianVoronoi.VoronoiPolygon","page":"API Documentation","title":"Main.LagrangianVoronoi.populate_rand!","text":"populate_rand!(grid::VoronoiGrid{T}; charfun, ic!)\n\nPopulate computational domain with polygons arranged randomly. This initializing method is not recommended because the mesh will have very low quality. Keyword parameters:\n\ncharfun: the characteristic function; only those areas where charfun(x) = true are populated\nic!: the initial condition; ic!(p) is called on every polygon after the mesh is generated\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.populate_rect!-Union{Tuple{Main.LagrangianVoronoi.VoronoiGrid{T}}, Tuple{T}} where T<:Main.LagrangianVoronoi.VoronoiPolygon","page":"API Documentation","title":"Main.LagrangianVoronoi.populate_rect!","text":"populate_rect!(grid::VoronoiGrid{T}; charfun, ic!)\n\nPopulate computational domain with Cartesian grid. Keyword parameters:\n\ncharfun: the characteristic function; only those areas where charfun(x) = true are populated\nic!: the initial condition; ic!(p) is called on every polygon after the mesh is generated\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.populate_vogel!-Union{Tuple{Main.LagrangianVoronoi.VoronoiGrid{T}}, Tuple{T}} where T<:Main.LagrangianVoronoi.VoronoiPolygon","page":"API Documentation","title":"Main.LagrangianVoronoi.populate_vogel!","text":"populate_vogel!(grid::VoronoiGrid{T}; charfun, center, ic!)\n\nPopulate computational domain with polygons arranged on Vogel spiral. Keyword parameters:\n\ncharfun: the characteristic function; only those areas where charfun(x) = true are populated\ncenter: the center of the spiral\nic!: the initial condition; ic!(p) is called on every polygon after the mesh is generated\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.PressureOperator","page":"API Documentation","title":"Main.LagrangianVoronoi.PressureOperator","text":"PressureOperator(grid::VoronoiGrid)\n\nConstruct the operator for pressure system. It is symmetric and positive-definite.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.LagrangianVoronoi.PressureSolver","page":"API Documentation","title":"Main.LagrangianVoronoi.PressureSolver","text":"PressureSolver(grid::VoronoiGrid; verbose::Bool)\n\nConstruct the solver for pressure system.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.LagrangianVoronoi.eint-Tuple{Main.LagrangianVoronoi.VoronoiPolygon}","page":"API Documentation","title":"Main.LagrangianVoronoi.eint","text":"eint(p::VoronoiPolygon)::Float64\n\nReturn the internal energy of a Voronoi Polygon.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.find_pressure!","page":"API Documentation","title":"Main.LagrangianVoronoi.find_pressure!","text":"find_pressure!(solver::PressureSolver, dt::Float64, niter::Int64)\n\nFind the estimated value of pressure field at the next time step.  Integer niter is the number fixed point iteratrions.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Main.LagrangianVoronoi.gravity_step!-Tuple{Main.LagrangianVoronoi.VoronoiGrid, StaticArraysCore.SVector{2, Float64}, Float64}","page":"API Documentation","title":"Main.LagrangianVoronoi.gravity_step!","text":"gravity_step!(grid::VoronoiGrid, g::RealVector, dt::Float64)\n\nUpdate velocity field and specific energy by a gravitational force.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.ideal_eos!","page":"API Documentation","title":"Main.LagrangianVoronoi.ideal_eos!","text":"ideal_eos!(grid::VoronoiGrid, gamma = 1.4; Pmin)\n\nCompute pressure and sound speed from internal energy and density using ideal gas equation of state. Number gamma is adiabatic index and Pmin can specify least possible value pressure. In the semi-implicit scheme, this value of pressure is used as an initial condition for an implicit solver.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Main.LagrangianVoronoi.pressure_step!-Tuple{Main.LagrangianVoronoi.VoronoiGrid, Float64}","page":"API Documentation","title":"Main.LagrangianVoronoi.pressure_step!","text":"pressure_step!(grid::VoronoiGrid, dt::Float64)\n\nUpdate the velocity and energy by the pressure field. This assumes that pressure was already determined.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.stiffened_eos!","page":"API Documentation","title":"Main.LagrangianVoronoi.stiffened_eos!","text":"stiffened_eos!(grid::VoronoiGrid, gamma = 1.4; P0)\n\nCompute pressure and sound speed from internal energy and density using ideal gas equation of state. Number gamma is adiabatic index and P0 is the stiffness constant. Stiffened equation of state fares better for flows with very low Mach number.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Main.LagrangianVoronoi.MultiphaseProjector","page":"API Documentation","title":"Main.LagrangianVoronoi.MultiphaseProjector","text":"MultiphaseProjector(grid::VoronoiGrid)\n\nA linear operator which appears in the multiphase projection system. It is symmetric and positive-definite.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.LagrangianVoronoi.MultiphaseSolver","page":"API Documentation","title":"Main.LagrangianVoronoi.MultiphaseSolver","text":"MultiphaseSolver(grid::VoronoiGrid, quality_threshold::Float64 = 0.25)\n\nConstruct a solver for the multiphase projection step.  A keyword argument quality_threshold determines when dv should not be projected because the quality of the cell is too poor. In these problematic cases, stability of the simulation takes priority over physical accuracy. \n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.LagrangianVoronoi.find_dv!","page":"API Documentation","title":"Main.LagrangianVoronoi.find_dv!","text":"find_dv!(grid::VoronoiGrid, dt::Float64, alpha::Float64 = 1.0)\n\nDetermine dv, the repair velocity. This is the first step of mesh relaxation procedure and is needed to maintain sufficiently high mesh quality. The repair velocity is chosen to be proportional to Frobenius norm of velocity deformation tensor D and inversely proportional to the mesh quality squared. There is also multiplicative dimensionless parameter alpha with default value alpha = 1. Higher alpha causes the Voronoi cells to be rounder (= better) but also less genuinly Lagrangian.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Main.LagrangianVoronoi.multiphase_projection!-Tuple{Main.LagrangianVoronoi.MultiphaseSolver}","page":"API Documentation","title":"Main.LagrangianVoronoi.multiphase_projection!","text":"multiphase_projection!(solver::MultiphaseSolver)\n\nSolve the linear system to find an orthogonal projection of dv to a constraint space which gurantees conservation of area for every fluid phase. You only need this for multiphase flows. You can also run multiphase problems without it but expect some artificial density ridges between phases of different densities.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.relaxation_step!-Tuple{Main.LagrangianVoronoi.VoronoiGrid, Float64}","page":"API Documentation","title":"Main.LagrangianVoronoi.relaxation_step!","text":"relaxation_step!(grid::VoronoiGrid, dt::Float64; rusanov::Bool = true)\n\nUpdate the variables by taking into account the repair velocity dv. The repair velocity should be known before the relalaxation_step! is called. See find_dv!. The mass, momentum and energy of each cell is updated by solving one step of an advection problem. A keyword boolean argument rusanov controls the use of a Rusanov approximate Riemann solver. The Rusanov flux is recommended to prevent the generation of new extrema (like negative density) and decrease of entropy. This is a second step of the mesh relaxation procedure (or maybe third, if your simulation involves a multiphase projector).\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.SimulationWorkspace","page":"API Documentation","title":"Main.LagrangianVoronoi.SimulationWorkspace","text":"SimulationWorkspace\n\nAbstract type for containing the computational grid, solvers and global variables. This methods should be defined for an instance sim of SimulationWorkspace:\n\nstep!(sim, time::Float64)\npostproc!(sim, time::Float64) [optional] \n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.LagrangianVoronoi.run!-Tuple{Main.LagrangianVoronoi.SimulationWorkspace, Float64, Float64, Function}","page":"API Documentation","title":"Main.LagrangianVoronoi.run!","text":"run!(sim::SimulationWorkspace, dt::Float64, t_end::Float64, step!::Function; kwargs...)\n\nA utility function for time-marching and exporting the results.  Specify the time step dt, final time t_end and a function  step(simSimulationWorkspace timeFloat64) Keyword arguments:\n\nnframes::Bool (how many times should I export the data?)\npath::String (where to export the data?)\nsave_points::Bool (should I export the point data?)\nsave_grid:::Bool (should I export the grid data?)\nsave_csv::Bool (should I export global variables as a csv data?)\nvtp_vars (which local variables should I export?)\ncsv_vars (which global variables should I export?)\npostproc!::Function (If provided, postproc!(sim, dt) is called each time just before the data is saved. \n\nUse this for some (expensive) post proccessing that affects the output files, not the simulation itself.)\n\nNote this assumes constant time step. See examples/sedov.jl for an example with adaptive time step.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.ThreadedVec","page":"API Documentation","title":"Main.LagrangianVoronoi.ThreadedVec","text":"ThreadedVec\n\nA mulithreaded vector which uses @batch for algebraic operations.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.LagrangianVoronoi.VoronoiGrid","page":"API Documentation","title":"Main.LagrangianVoronoi.VoronoiGrid","text":"VoronoiGrid{T}(boundary_rect::Rectangle, dr::Float64, kwargs...)\n\nThis struct contains all information about geometry, the Voronoi mesh and a cell list.  Type variable T specifies the Voronoi Polygon, boundary_rect defines the computational domain and dr is the default resolution  (a particle will typically occupy an area of size dr^2). \n\nKeyword arguments:\n\nxperiodic::Bool: Is our domain periodic in the horizontal direction?\nyperiodic::Bool: Is our domain periodic in the vertical direction?\nh the size of cells in the cell_list\nr_max the maximum possible distance between neighboring cells\n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.LagrangianVoronoi.get_arrow-Tuple{StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}, Main.LagrangianVoronoi.VoronoiGrid}","page":"API Documentation","title":"Main.LagrangianVoronoi.get_arrow","text":"get_arrow(x::RealVector, y::RealVector, grid::VoronoiGrid)::RealVector\n\nReturn a vector from y to x. Equal to x - y on non-periodic domains.  For periodic rectangle, the shortest possible vector is returned.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.nearest_polygon-Union{Tuple{T}, Tuple{Main.LagrangianVoronoi.VoronoiGrid{T}, StaticArraysCore.SVector{2, Float64}}} where T<:Main.LagrangianVoronoi.VoronoiPolygon","page":"API Documentation","title":"Main.LagrangianVoronoi.nearest_polygon","text":"nearest_polygon(grid::VoronoiGrid{T}, x::RealVector)::T\n\nFind the nearest polygon to the reference point x. \n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.LagrangianVoronoi.remesh!-Tuple{Main.LagrangianVoronoi.VoronoiGrid}","page":"API Documentation","title":"Main.LagrangianVoronoi.remesh!","text":"remesh!(grid::VoronoiGrid)\n\nGenerate all Voronoi cells by performing all Voronoi cuts. This is called automatically when the VoronoiGrid is populated and each the Voronoi generators move in space.\n\n\n\n\n\n","category":"method"},{"location":"examples/doubleshear.html#Example-4:-Double-Shear-Layer","page":"Example 4: Double Shear Layer","title":"Example 4: Double Shear Layer","text":"","category":"section"},{"location":"examples/doubleshear.html","page":"Example 4: Double Shear Layer","title":"Example 4: Double Shear Layer","text":"    <img src='../assets/doubleshear.png' alt='missing' width=\"75%\" height=\"50%\"><br>","category":"page"},{"location":"examples/doubleshear.html","page":"Example 4: Double Shear Layer","title":"Example 4: Double Shear Layer","text":"In this setup, borrowed from this paper, we consider a periodic domain and an initial velocity field","category":"page"},{"location":"examples/doubleshear.html","page":"Example 4: Double Shear Layer","title":"Example 4: Double Shear Layer","text":"u = tanhleft(xi left(y - frac14right) right) quad y  frac12","category":"page"},{"location":"examples/doubleshear.html","page":"Example 4: Double Shear Layer","title":"Example 4: Double Shear Layer","text":"u = tanhleft(xi left(frac34 - yright) right) quad y geq frac12","category":"page"},{"location":"examples/doubleshear.html","page":"Example 4: Double Shear Layer","title":"Example 4: Double Shear Layer","text":"v = delta sin(2 pi x)","category":"page"},{"location":"examples/doubleshear.html","page":"Example 4: Double Shear Layer","title":"Example 4: Double Shear Layer","text":"with delta = 005, xi = 30, with constant initial density rho_0 = 1, viscosity mu = 2E-4 and pressure P_0 = frac1gamma These conditions generate an interesting flow pattern, which is essentially a Kelvin-Helmholtz instability. The problem relies on a periodic boundary condition which must be specified in the VoronoiGrid constructor.","category":"page"},{"location":"examples/doubleshear.html","page":"Example 4: Double Shear Layer","title":"Example 4: Double Shear Layer","text":"module doubleshear\ninclude(\"../src/LagrangianVoronoi.jl\")\nusing .LagrangianVoronoi, LinearAlgebra, Polyester\n\nconst rho0 = 1.0\nconst xlims = (0.0, 1.0)\nconst ylims = (0.0, 1.0)\nconst mu = 2e-4\nconst dr = 1e-2\nconst gamma = 1.4\nconst P0 = 100.0/gamma\n\nconst delta = 0.05\nconst xi = 30.0\nconst v_char = 2.0\nconst dt = 0.1*dr/v_char\n\nconst t_end = 1.8\n\nconst export_path = \"results/doubleshear\"\nconst nframes = 100\n\nfunction ic!(p::VoronoiPolygon)\n    p.v = v_init(p.x)\n    p.rho = rho0\n    p.mass = p.rho*area(p)\n    p.P = P0\n    p.e = 0.5*norm_squared(p.v) + p.P/(p.rho*(gamma - 1.0))\n    p.mu = mu\nend\n\nfunction v_init(x::RealVector)::RealVector\n    u =  (x[2] <= 0.5) ? tanh(xi*(x[2] - 0.25)) : tanh(xi*(0.75 - x[2]))\n    v = delta*sin(2pi*x[1])\n    return RealVector(u,v)\nend","category":"page"},{"location":"examples/doubleshear.html","page":"Example 4: Double Shear Layer","title":"Example 4: Double Shear Layer","text":"In this example, we would like to compute vorticity. Unfortunately, the predefined Navier-Stokes polygon is not equipped with a vorticity field. However, we can create our custom type PolygonWithVorticity and perform all computations with it.","category":"page"},{"location":"examples/doubleshear.html","page":"Example 4: Double Shear Layer","title":"Example 4: Double Shear Layer","text":"@kwdef mutable struct PolygonWithVorticity <: VoronoiPolygon\n    @fluid_variables    # all standard variables\n    vort::Float64 = 0.0 # vorticity\nend\nconst GridWithVorticity = VoronoiGrid{PolygonWithVorticity}\n\nmutable struct Simulation <: SimulationWorkspace\n    grid::GridWithVorticity\n    solver::PressureSolver{PolygonWithVorticity}\n    E::Float64\n    S::Float64\n    E0::Float64\n    S0::Float64\n    first_step::Bool\n    Simulation() = begin\n        domain = Rectangle(xlims = xlims, ylims = ylims)\n        grid = GridWithVorticity(domain, dr, xperiodic = true, yperiodic = true) # the domain is periodic both horizontally and vertically\n        populate_lloyd!(grid, ic! = ic!)\n        solver = PressureSolver(grid)\n        return new(grid, solver, 0.0, 0.0, 0.0, 0.0, true)\n    end\nend","category":"page"},{"location":"examples/doubleshear.html","page":"Example 4: Double Shear Layer","title":"Example 4: Double Shear Layer","text":"We need to define a custom function for vorticity evaluation. The vorticity can be evauluated using moving least squares. (Also known as \"linear reconstruction\" in some circles.) This is not the only way how vorticity can be approximated.","category":"page"},{"location":"examples/doubleshear.html","page":"Example 4: Double Shear Layer","title":"Example 4: Double Shear Layer","text":"function get_vort!(grid::GridWithVorticity)\n    @batch for p in grid.polygons\n        gradu = movingls(LinearExpansion, grid, p, p -> p.v[1])\n        gradv = movingls(LinearExpansion, grid, p, p -> p.v[2])\n        p.vort = gradv[1] - gradu[2]\n    end\nend","category":"page"},{"location":"examples/doubleshear.html","page":"Example 4: Double Shear Layer","title":"Example 4: Double Shear Layer","text":"The remainder of the script is as usual.","category":"page"},{"location":"examples/doubleshear.html","page":"Example 4: Double Shear Layer","title":"Example 4: Double Shear Layer","text":"function step!(sim::Simulation, t::Float64)\n    move!(sim.grid, dt)\n    ideal_eos!(sim.grid, gamma)\n    find_pressure!(sim.solver, dt)\n    pressure_step!(sim.grid, dt)\n    find_D!(sim.grid)\n    viscous_step!(sim.grid, dt)\n    find_dv!(sim.grid, dt)\n    relaxation_step!(sim.grid, dt)\n    return\nend\n\nfunction postproc!(sim::Simulation, t::Float64)\n    get_vort!(sim.grid)\n    @show t\n    grid = sim.grid\n    sim.E = 0.0\n    sim.S = 0.0\n    for p in grid.polygons\n        sim.E += p.mass*p.e\n        sim.S += p.mass*(log(abs(p.P/P0)) - gamma*log(abs(p.rho/rho0)))\n    end\n    if sim.first_step\n        sim.E0 = sim.E\n        sim.S0 = sim.S\n        sim.first_step = false\n    end\n    sim.E -= sim.E0\n    sim.S -= sim.S0\n    @show sim.E\n    @show sim.S\n    println()\n    return\nend\n\nfunction main()\n    sim = Simulation()\n    run!(sim, dt, t_end, step!;\n        postproc! = postproc!,\n        nframes = nframes,\n        path = export_path,\n        save_csv = false,\n        save_points = true,\n        save_grid = true,\n        vtp_vars = (:P, :v, :rho, :vort)\n    )\nend\n\nif abspath(PROGRAM_FILE) == @__FILE__\n    main()\nend\n\nend","category":"page"},{"location":"examples/doubleshear.html","page":"Example 4: Double Shear Layer","title":"Example 4: Double Shear Layer","text":"","category":"page"},{"location":"examples/doubleshear.html","page":"Example 4: Double Shear Layer","title":"Example 4: Double Shear Layer","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/gresho.html#Example-1:-Gresho-Vortex-Benchmark","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"","category":"section"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"    <img src='../assets/gresho.png' alt='missing' width=\"75%\" height=\"50%\"><br>","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"Gresho vortex is a very simple test which allows to compare a numerical solution to analytical result for arbitrary Mach number. The setup is a domain (usually square) with a prescribed vortex as the initial condition. The vortex should be steady in theory but it is not trivial to reproduce such behavior in a numerical code, especially since the initial condition is not a differentiable function.","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"Let us start by including LagrangianVoronoi module and importing some useful libraries.","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"module gresho\ninclude(\"../src/LagrangianVoronoi.jl\")\nusing .LagrangianVoronoi, WriteVTK, LinearAlgebra, Match\nusing LaTeXStrings, DataFrames, CSV, Plots, Measures","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"Declare constant parameters of the simulation. Especially the Mach number and the resolution.","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"const rho0 = 1.0 # initial density\nconst xlims = (-0.5, 0.5)\nconst ylims = (-0.5, 0.5)\nconst N = 100 # resolution\nconst dr = 1.0/N\n\nconst dt = 0.1*dr\nconst t_end =  1.0\nconst nframes = 100 # number of time frames (how many times we save the simulation state)\n\nconst Ma = 0.1 # Mach number\nconst c0 = 1.0/Ma # speed of sound\nconst gamma = 1.4 # adiabatic index\nconst stiffened = (c0 > 100) # do we use ideal or stiffened gas model?\nconst P0 = rho0*c0^2/gamma # initial density in the vortex core\n\nconst export_path = \"results/gresho/Ma$Ma\"","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"Define the exact solution, which is the same as initial condition.","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"function v_exact(x::RealVector)::RealVector\n    omega = @match norm(x) begin\n        r, if r < 0.2 end => 5.0\n        r, if r < 0.4 end => 2.0/r - 5.0\n        _ => 0.0\n    end\n    return omega*RealVector(-x[2], x[1])\nend\n\nfunction P_exact(x::RealVector)::Float64\n    Pmin = (stiffened ? 0.0 : P0)\n    return @match norm(x) begin\n        r, if r < 0.2 end => Pmin + 12.5*r^2\n        r, if r < 0.4 end => Pmin + 4.0 + 4*log(5*r) - 20.0*r + 12.5*r^2\n        _ => Pmin - 2.0 + 4*log(2)\n    end\nend","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"This function enforces the inital condition on a VoronoiPolygon.","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"function ic!(p::VoronoiPolygon)\n    p.v = v_exact(p.x) # velocity\n    p.rho = rho0 # density\n    p.mass = p.rho*area(p) # mass\n    p.P = P_exact(p.x) # pressure\n    p.e = 0.5*norm_squared(p.v) + p.P/(p.rho*(gamma - 1.0)) # internal energy\nend","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"The Simulation worspace struct contains all simulation data, namely:","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"grid (and all local variables within)\npressure solver (allows us to solve an implicit system)\nglobal (non-constant) variables","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"Polygons are generated in its constructor.","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"mutable struct Simulation <: SimulationWorkspace\n    grid::GridNS\n    solver::PressureSolver{PolygonNS}\n    E::Float64  # total energy\n    l2_err::Float64 # L^2 error\n    Simulation() = begin\n        domain = Rectangle(xlims = xlims, ylims = ylims)\n        grid = GridNS(domain, dr)\n        populate_circ!(grid, ic! = ic!)\n        return new(grid, PressureSolver(grid), 0.0, 0.0)\n    end\nend","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"Function step! defines how simulation workspace changes when we update the time by dt. Number t is the simulation time before the update. We do not really need t but the module requires this argument.","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"function step!(sim::Simulation, t::Float64)\n    move!(sim.grid, dt)\n    if stiffened\n        stiffened_eos!(sim.grid, gamma, P0) # stiffened gas equation of state\n    else\n        ideal_eos!(sim.grid, gamma) # ideal gas equation of state\n    end\n    find_pressure!(sim.solver, dt)\n    pressure_step!(sim.grid, dt)\n    find_D!(sim.grid)\n    viscous_step!(sim.grid, dt)\n    find_dv!(sim.grid, dt)\n    relaxation_step!(sim.grid, dt)\n    return\nend","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"Function postproc!is called each time before the data is saved (much less often than step!). It can be used for post-processing but let's just print some information to the console.","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"function postproc!(sim::Simulation, t::Float64)\n    sim.l2_err = 0.0\n    sim.E = 0.0\n    for p in sim.grid.polygons\n        sim.l2_err += p.mass*norm_squared(p.v - v_exact(p.x))\n        sim.E += p.mass*p.e\n    end\n    sim.l2_err = sqrt(sim.l2_err)\n    percent = round(100*t/t_end, digits = 5)\n    println(\"t = $t ($(percent)%)\")\n    println(\"energy = $(sim.E)\")\n    println(\"error = $(sim.l2_err)\")\n    println()\nend","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"Wrap everything into the main function. Once the simulation ends, extract the velocity along midline and plot it.","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"function main()\n    sim = Simulation()\n    run!(sim, dt, t_end, step!;\n        path = export_path,\n        postproc! = postproc!,\n        vtp_vars = (:v, :P),      # local variables exported into vtp\n        csv_vars = (:E, :l2_err), # global variables exported into csv\n        nframes = nframes         # number of time frames\n    )\n    vy = Float64[]\n    vy_exact = Float64[]\n    x_range = 0.0:(2*dr):xlims[2]\n    for x1 in x_range\n        x = RealVector(x1, 0.0)\n        push!(vy, point_value(sim.grid, x, p -> p.v[2]))\n        push!(vy_exact, v_exact(x)[2])\n    end\n    csv_data = DataFrame(x = x_range, vy = vy, vy_exact = vy_exact)\n\tCSV.write(string(export_path, \"/midline_data.csv\"), csv_data)\n    plot_midline()\nend\n\n\nfunction plot_midline()\n    csv_data = CSV.read(string(export_path, \"/midline_data.csv\"), DataFrame)\n    plt = plot(\n        csv_data.x,\n        csv_data.vy_exact,\n        xlabel = L\"x\",\n        ylabel = L\"v_y\",\n        label = \"exact\",\n        color = :black,\n        axisratio = 0.5,\n        bottom_margin = 5mm,\n        linewidth = 2.0\n    )\n    plot!(\n        plt,\n        csv_data.x,\n        csv_data.vy,\n        label = \"simulation\",\n        markershape = :hex,\n        markersize = 3,\n        linewidth = 2.0\n    )\n    savefig(plt, string(export_path, \"/midline_plot.pdf\"))\nend","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"This piece of code allows to run the script from the terminal.","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"if abspath(PROGRAM_FILE) == @__FILE__\n    main()\nend\n\nend","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"","category":"page"},{"location":"examples/gresho.html","page":"Example 1: Gresho Vortex Benchmark","title":"Example 1: Gresho Vortex Benchmark","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/heat.html#Example-7:-Rayleigh-Bénard-Instability","page":"Example 7: Rayleigh-Bénard Instability","title":"Example 7: Rayleigh-Bénard Instability","text":"","category":"section"},{"location":"examples/heat.html","page":"Example 7: Rayleigh-Bénard Instability","title":"Example 7: Rayleigh-Bénard Instability","text":"    <img src='../assets/heat.png' alt='missing' width=\"50%\" height=\"50%\"><br>","category":"page"},{"location":"examples/heat.html","page":"Example 7: Rayleigh-Bénard Instability","title":"Example 7: Rayleigh-Bénard Instability","text":"This test is similar to Rayleigh-Taylor but even more amazing. The top side of the domain is hot and the bottom is cold. The hot fluid expands and rises up, then cools again and sinks. The resulting dynamical pattern is called a convective cell. It is somehow related to atmosphere and weather. You can read more on wikipedia.","category":"page"},{"location":"examples/heat.html","page":"Example 7: Rayleigh-Bénard Instability","title":"Example 7: Rayleigh-Bénard Instability","text":"module heat\ninclude(\"../src/LagrangianVoronoi.jl\")\nusing .LagrangianVoronoi\n\n\nconst g = 9.8 #gravitation acceleration\nconst mu = 1e-4 #dynamic viscosity\nconst H = 0.1 #height\nconst W = 0.1\nconst gamma = 1.4 #adiabatic index\nconst rho0 = 10.0\n\nconst cV = 10.0  #sp. heat capacity\nconst R = (gamma - 1.0)*cV\nconst thermal_k = mu*cV*gamma/0.71 #thermal conductivity\n\nconst P0 = 1e4\nconst c0 = sqrt(gamma*P0/rho0)\nconst Tu = P0/(rho0*R) #temperature of upper boundary (cooler)\nconst Td = 1000.0 #30.0 #Tu*(1.0 + contrast) #temperature of lower boundary (heater)\n\nconst export_path = \"results/heat\"\nconst dr = H/100\nconst v_char = 2.0\nconst dt = 0.1*dr/v_char\nconst nframes = 400\nconst t_end = 1.0\n\nfunction print_info()\n    thermal_D = thermal_k/(rho0*gamma*cV) #thermal diffusivity\n    thermal_a = 1.0/Tu\n    nu = mu/rho0\n    @show Pr = nu/thermal_D # Prandtl number\n    @show Ra = thermal_a*g*(Td-Tu)*(H^3)/(nu*thermal_D) # Rayleigh number\nend","category":"page"},{"location":"examples/heat.html","page":"Example 7: Rayleigh-Bénard Instability","title":"Example 7: Rayleigh-Bénard Instability","text":"Define the initial state (exponential atmosphere) and the boundary condition for temperature.","category":"page"},{"location":"examples/heat.html","page":"Example 7: Rayleigh-Bénard Instability","title":"Example 7: Rayleigh-Bénard Instability","text":"function exp_atmo!(p::VoronoiPolygon)\n    p.T = Tu\n    p.P = P0*exp(-g*p.x[2]/(R*Tu))\n    p.e = cV*p.T\n    p.rho = p.P/(R*p.T)\n    p.mass = p.rho*area(p)\n    p.k = thermal_k\n    p.cV = cV\nend\n\nfunction T_bc(::RealVector, bdary::Int)::Float64\n    if (bdary == BDARY_DOWN)\n        return Td\n    elseif (bdary == BDARY_UP)\n        return Tu\n    end\n    return NaN # NaN indicates an adiabatic wall\nend","category":"page"},{"location":"examples/heat.html","page":"Example 7: Rayleigh-Bénard Instability","title":"Example 7: Rayleigh-Bénard Instability","text":"The rest is fairly standard, except we also need to include Fourier diffusion in our time-marching scheme.","category":"page"},{"location":"examples/heat.html","page":"Example 7: Rayleigh-Bénard Instability","title":"Example 7: Rayleigh-Bénard Instability","text":"mutable struct Simulation <: SimulationWorkspace\n    grid::GridNS\n    solver::PressureSolver{PolygonNS}\n    E::Float64\n    S::Float64\n    E_kinetic::Float64\n    Simulation() = begin\n        xlims = (0.0, W)\n        ylims = (0.0, H)\n        domain = Rectangle(xlims = xlims, ylims = ylims)\n        grid = GridNS(domain, dr, xperiodic = true)\n        populate_lloyd!(grid, ic! = exp_atmo!)\n        return new(grid, PressureSolver(grid), 0.0, 0.0, 0.0)\n    end\nend\n\nfunction step!(sim::Simulation, t::Float64)\n    move!(sim.grid, dt)\n    gravity_step!(sim.grid, -g*VECY, dt)\n    ideal_eos!(sim.grid, gamma)\n    find_pressure!(sim.solver, dt)\n    pressure_step!(sim.grid, dt)\n    ideal_temperature!(sim.grid) # find the temperature according to ideal gas laws\n    fourier_step!(sim.grid, dt)  # update the temperature by Fourier diffusion\n    heat_from_bdary!(sim.grid, dt, T_bc, gamma) # add heat flux from boundaries\n    find_D!(sim.grid)\n    viscous_step!(sim.grid, dt)\n    find_dv!(sim.grid, dt)\n    relaxation_step!(sim.grid, dt)\n    return\nend\n\nfunction postproc!(sim::Simulation, t::Float64)\n    sim.S = 0.0\n    sim.E = 0.0\n    sim.E_kinetic = 0.0\n    P0 = rho0*c0^2/gamma\n    for p in sim.grid.polygons\n        sim.S += p.mass*p.cV*(log(abs(p.P/P0)) - gamma*log(abs(p.rho/rho0)))\n        sim.E += p.mass*p.e\n        sim.E_kinetic += 0.5*p.mass*norm_squared(p.v)\n    end\n    percent = round(100*t/t_end, digits = 5)\n    println(\"t = $t ($(percent)%)\")\n    @show sim.E\n    @show sim.S\n    @show sim.E_kinetic\n    println()\nend\n\nfunction main()\n    print_info()\n    sim = Simulation()\n    run!(sim, dt, t_end, step!; path = export_path,\n        vtp_vars = (:v, :P, :T, :rho),\n        postproc! = postproc!,\n        nframes = nframes\n    )\nend\n\nif abspath(PROGRAM_FILE) == @__FILE__\n    main()\nend\n\nend","category":"page"},{"location":"examples/heat.html","page":"Example 7: Rayleigh-Bénard Instability","title":"Example 7: Rayleigh-Bénard Instability","text":"","category":"page"},{"location":"examples/heat.html","page":"Example 7: Rayleigh-Bénard Instability","title":"Example 7: Rayleigh-Bénard Instability","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/taylorgreen.html#Example-8:-Taylor-Green-Vortex","page":"Example 8: Taylor-Green Vortex","title":"Example 8: Taylor-Green Vortex","text":"","category":"section"},{"location":"examples/taylorgreen.html","page":"Example 8: Taylor-Green Vortex","title":"Example 8: Taylor-Green Vortex","text":"In the field of mathematical modeling, benchmarks can be divided into two categories: those which are very cool but completely useless and those which are useful but extremely boring. Taylor-Green vortex belong to the second category. There is nothing interesting here: the fluid has only one phase and the velocity field is smooth and steady periodic vortex lattice. However, it has an analytic solution and we can use it to assess the convergence rate. So far, we only have linear rate but maybe in distant future, somebody implements a second order operators for Lagrangian Voronoi cells.","category":"page"},{"location":"examples/taylorgreen.html","page":"Example 8: Taylor-Green Vortex","title":"Example 8: Taylor-Green Vortex","text":"module taylorgreen\ninclude(\"../src/LagrangianVoronoi.jl\")\nusing .LagrangianVoronoi, WriteVTK, LinearAlgebra\nusing DataFrames, CSV, Plots, Measures\n\n\nconst rho0 = 1.0\nconst xlims = (0.0, 1.0)\nconst ylims = (0.0, 1.0)\nconst t_end = 0.2\nconst Res = [400, 1000, Inf]\nconst Ns = [32, 48, 72, 108, 162]\nconst c0 = 1000.0\nconst gamma = 1.4\nconst P0 = rho0*c0^2/gamma\n\nconst l_char = 1.0\nconst v_char = 1.0\n\nconst export_path = \"results/taylorgreen\"\n\nfunction v_max(Re::Float64, t::Float64)::Float64\n    return exp(-8.0*pi^2*t/Re)\nend\n\nfunction ic!(p::VoronoiPolygon, Re::Float64)\n    p.v = v_exact(p.x, Re, 0.0)\n    p.rho = rho0\n    p.mass = p.rho*area(p)\n    p.P = P_exact(p.x, Re, 0.0)\n    p.e = 0.5*norm_squared(p.v) + p.P/(p.rho*(gamma - 1.0))\n    p.mu = 1.0/Re\nend\n\nfunction v_exact(x::RealVector, Re::Float64, t::Float64)::RealVector\n    u0 =  cos(2pi*x[1])*sin(2pi*x[2])\n    v0 = -sin(2pi*x[1])*cos(2pi*x[2])\n    return v_max(Re, t)*(u0*VECX + v0*VECY)\nend\n\nfunction P_exact(x::RealVector, Re::Float64, t::Float64)::Float64\n    return 0.5*(v_max(Re, t)^2)*(sin(2pi*x[1])^2 + sin(2pi*x[2])^2 - 1.0)\nend\n\nmutable struct Simulation <: SimulationWorkspace\n    dr::Float64\n    dt::Float64\n    Re::Float64\n    grid::GridNS\n    solver::PressureSolver{PolygonNS}\n    v_err::Float64\n    P_err::Float64\n    E_err::Float64\n    div::Float64\n    first_it::Bool\n    E0::Float64\n    Simulation(N::Int, Re::Number) = begin\n        Re = Float64(Re)\n        dr = 1.0/N\n        dt = 0.1*min(dr, dr^2*Re)\n        domain = Rectangle(xlims = xlims, ylims = ylims)\n        grid = GridNS(domain, dr, xperiodic = true, yperiodic = true)\n        _ic! = (p -> ic!(p, Re))\n        populate_hex!(grid, ic! = _ic!)\n        solver = PressureSolver(grid)\n        return new(dr, dt, Re, grid, solver, 0.0, 0.0, 0.0, 0.0, true, 0.0)\n    end\nend\n\nfunction step!(sim::Simulation, t::Float64)\n    move!(sim.grid, sim.dt)\n    stiffened_eos!(sim.grid, gamma, P0)\n    find_pressure!(sim.solver, sim.dt)\n    pressure_step!(sim.grid, sim.dt)\n    find_D!(sim.grid)\n    viscous_step!(sim.grid, sim.dt; artificial_viscosity = false)\n    find_dv!(sim.grid, sim.dt)\n    relaxation_step!(sim.grid, sim.dt)\n    return\nend\n\nfunction postproc!(sim::Simulation, t::Float64)\n    @show t\n    grid = sim.grid\n    sim.P_err = 0.0\n    sim.v_err = 0.0\n    sim.E_err = 0.0\n    sim.div = 0.0\n    p_avg = 0.0\n    for p in grid.polygons\n        p_avg += area(p)*p.P\n    end\n    for p in grid.polygons\n        sim.E_err += p.mass*p.e\n        sim.v_err += area(p)*norm_squared(p.v - v_exact(p.x, sim.Re, t))\n        sim.P_err += area(p)*(p.P - p_avg - P_exact(p.x, sim.Re, t))^2\n        sim.div += area(p)*(dot(p.D, MAT1)^2)\n    end\n    if sim.first_it\n        sim.E0 = sim.E_err\n    end\n    sim.E_err -= sim.E0\n    sim.P_err = sqrt(sim.P_err)\n    sim.v_err = sqrt(sim.v_err)\n    sim.div = sqrt(sim.div)\n    @show sim.v_err\n    @show sim.P_err\n    @show sim.E_err\n    println()\n    sim.first_it = false\n    return\nend\n\nfunction simple_test(Re::Number, N::Int)\n    sim = Simulation(N, Re)\n    run!(sim, sim.dt, t_end, step!;\n        postproc! = postproc!,\n        nframes = 100,\n        path = joinpath(export_path, \"N$N\"),\n        save_csv = false,\n        save_points = false,\n        save_grid = true,\n        vtp_vars = (:P, :v, :rho, :quality, :dv)\n    )\nend\n\nfunction get_convergence(Re::Number)\n    @show Re\n    println(\"***\")\n    path = joinpath(export_path, \"$(Re)\")\n    if !ispath(path)\n        mkpath(path)\n    end\n    pvd = paraview_collection(joinpath(path, \"cells.pvd\"))\n    E_errs = Float64[]\n    v_errs = Float64[]\n    P_errs = Float64[]\n    divs = Float64[]\n    for N in Ns\n        @show N\n        sim = Simulation(N, Re)\n        run!(sim, sim.dt, t_end, step!;\n            postproc! = postproc!,\n            nframes = 5,\n            path = path,\n            save_csv = false,\n            save_points = false,\n            save_grid = false\n        )\n        push!(E_errs, abs(sim.E_err))\n        push!(v_errs, sim.v_err)\n        push!(P_errs, sim.P_err)\n        push!(divs, sim.div)\n        pvd[N] = export_grid(sim.grid, joinpath(path, \"frame$(N).vtp\"), :v, :P)\n    end\n    vtk_save(pvd)\n    csv = DataFrame(Ns = Ns, E_errs = E_errs, v_errs = v_errs, P_errs = P_errs, divs = divs)\n\tCSV.write(joinpath(path, \"convergence.csv\"), csv)\n    for var in (:E_errs, :v_errs, :P_errs, :divs)\n        println(var)\n        b = linear_regression(Ns, getproperty(csv, var))\n        println(\"noc = $(b[1])\")\n    end\n    println()\n    return\nend\n\nfunction linear_regression(x, y)\n    N = length(x)\n    logx = log10.(x)\n    logy = log10.(y)\n    A = [logx ones(N)]\n    b = A\\logy\n    return b\nend\n\nfunction main()\n    for Re in Res\n        get_convergence(Re)\n    end\n    makeplots()\n    return\nend\n\nfunction makeplots()\n    rainbow = cgrad(:darkrainbow, length(Res), categorical = true)\n    shapes = [:circ, :hex, :square, :star4, :star5, :utriangle, :dtriangle, :pentagon, :rtriangle, :ltriangle]\n    for var in (:v_errs, :P_errs, :E_errs, :divs)\n        myfont = font(12)\n        plt = plot(\n            axis_ratio = 1,\n            xlabel = \"log resolution\", ylabel = \"log error\",\n            legend = :bottomleft, #:outerright,\n            xtickfont=myfont,\n            ytickfont=myfont,\n            guidefont=myfont,\n            legendfont=myfont,\n        )\n        i = 1\n        ymin = +Inf\n        ymax = -Inf\n        xmax = -Inf\n        for Re in Res\n            label = \"$(Re)\"\n            path = joinpath(export_path, label, \"convergence.csv\")\n            csv = CSV.read(path, DataFrame)\n            y = getproperty(csv, var)\n            x = csv.Ns\n            plot!(plt,\n                log10.(x), log10.(y), linestyle = :dot,\n                markershape = shapes[i],\n                label = Re == Inf ? \"Re = Inf\" : \"Re = $(Int(Re))\",\n                color = rainbow[i],\n            )\n            xmax = max(xmax, log10(maximum(x)))\n            ymax = max(ymax, log10(maximum(y)))\n            ymin = min(ymin, log10(minimum(y)))\n            i += 1\n        end\n        trix = xmax + 0.5\n        triy = ymax - 0.1\n        sidelen = 0.2*(ymax-ymin)\n        draw_triangle!(plt, trix, triy, 1, sidelen)\n        draw_triangle!(plt, trix, triy, 2, sidelen)\n        savefig(plt, joinpath(export_path, \"$(var).pdf\"))\n    end\n    return\nend\n\nfunction draw_triangle!(plt, x, y, order = 1, sidelen = 1.0)\n    a = sidelen\n    shape = [(x-a,y), (x,y), (x, y-a*order), (x-a,y)]\n    plot!(plt, shape, linecolor = :black, linestyle = :dash, label = :none)\nend\n\nif abspath(PROGRAM_FILE) == @__FILE__\n    main()\nend\n\nend","category":"page"},{"location":"examples/taylorgreen.html","page":"Example 8: Taylor-Green Vortex","title":"Example 8: Taylor-Green Vortex","text":"","category":"page"},{"location":"examples/taylorgreen.html","page":"Example 8: Taylor-Green Vortex","title":"Example 8: Taylor-Green Vortex","text":"This page was generated using Literate.jl.","category":"page"},{"location":"index.html#LagrangianVoronoi.jl-Documentation","page":"Home","title":"LagrangianVoronoi.jl - Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A method for Euler/Navier-Stokes fluids combining Lagrangian paradigm with Voronoi tesselation.  The method is described in our publication but recently, we extended the code for compressible flows. You will need paraview to plot the results.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"    <img src=\"assets/voronoimesh.png\" alt=\"\" style=\"height: 400px\"/>","category":"page"},{"location":"examples/rayleightaylor.html#Example-5:-Rayleigh-Taylor-Instability","page":"Example 5: Rayleigh-Taylor Instability","title":"Example 5: Rayleigh-Taylor Instability","text":"","category":"section"},{"location":"examples/rayleightaylor.html","page":"Example 5: Rayleigh-Taylor Instability","title":"Example 5: Rayleigh-Taylor Instability","text":"    <img src='../assets/rayleightaylor.png' alt='missing' width=\"50%\" height=\"50%\"><br>","category":"page"},{"location":"examples/rayleightaylor.html","page":"Example 5: Rayleigh-Taylor Instability","title":"Example 5: Rayleigh-Taylor Instability","text":"Rayleigh-Taylor is a very nice qualitative test where heavier fluid rest above a light fluid in a uniform gravitational field. This balance is obviously unstable and the fluids will try to minimize their potential by replacing each other. The transitional state often looks like a mushroom. You can get this in real life when you mix eg. coffee with milk. Some people believe this stuff is important and they made a page on wikipedia for it.","category":"page"},{"location":"examples/rayleightaylor.html","page":"Example 5: Rayleigh-Taylor Instability","title":"Example 5: Rayleigh-Taylor Instability","text":"module rayleightaylor\n\ninclude(\"../src/LagrangianVoronoi.jl\")\nusing .LagrangianVoronoi\n\nconst rho_d = 1.0 # density of lower fluid\nconst rho_u = 1.8 # density of upper fluid\nconst Re = 420.0 # Reynold number\nconst Fr = 1.0 # Froude number\nconst c = 20.0 # speed of sound\nconst g = 1/(Fr^2) # gravitational acceleration\nconst gamma = 1.4\n\nconst xlims = (0.0, 1.0)\nconst ylims = (0.0, 2.0)\n\nconst N = 100 #resolution\nconst dr = 1.0/N\nconst h = 2*dr\n\nconst v_char = 1.0\nconst l_char = 1.0\nconst dt = 0.1*dr/v_char\nconst t_end =  5.0\nconst nframes = 400\n\nconst export_path = \"results/rayleightaylor\"","category":"page"},{"location":"examples/rayleightaylor.html","page":"Example 5: Rayleigh-Taylor Instability","title":"Example 5: Rayleigh-Taylor Instability","text":"Let us define some phase markers for upper and lower fluid. The phase markers must be non-negative integers.","category":"page"},{"location":"examples/rayleightaylor.html","page":"Example 5: Rayleigh-Taylor Instability","title":"Example 5: Rayleigh-Taylor Instability","text":"const UP = 0\nconst DOWN = 1","category":"page"},{"location":"examples/rayleightaylor.html","page":"Example 5: Rayleigh-Taylor Instability","title":"Example 5: Rayleigh-Taylor Instability","text":"Accelerate the instability with a good initial condition, where upper and lower fluid are divided by a sinusoid.","category":"page"},{"location":"examples/rayleightaylor.html","page":"Example 5: Rayleigh-Taylor Instability","title":"Example 5: Rayleigh-Taylor Instability","text":"function dividing_curve(x::Float64)::Float64\n    return 1.0 - 0.15*sin(2*pi*x[1])\nend\n\nfunction ic!(p::VoronoiPolygon)\n    dy = dividing_curve(p.x[1])\n    p.phase = (p.x[2] > dy ? 0 : 1)\n    p.rho = (p.phase == UP ? rho_u : rho_d)\n    p.mass = p.rho*area(p)\n    p.mu = p.rho/Re\n    p.P = rho_d*c^2/gamma\n    p.P -= max(p.x[2], dy)*rho_d*g\n    p.P -= min(0.0, p.x[2]-dy)*rho_u*g\n    p.e = p.P/(p.rho*(gamma - 1.0)) + g*p.x[2]\nend","category":"page"},{"location":"examples/rayleightaylor.html","page":"Example 5: Rayleigh-Taylor Instability","title":"Example 5: Rayleigh-Taylor Instability","text":"This time we need two different implicit solvers. The psolver is the good old pressure solver and projects velocity to a constraint space with zero divergence (or something similar in the compressible regime). The new msolver projects the repair velocity to a constraint space where it does not mess up the fluid phases. It is not so important, but had I not implemented it, those mathematical puritans would kick me from a Cantor staircase and stab me with a Weierstrass function.","category":"page"},{"location":"examples/rayleightaylor.html","page":"Example 5: Rayleigh-Taylor Instability","title":"Example 5: Rayleigh-Taylor Instability","text":"mutable struct Simulation <: SimulationWorkspace\n    grid::GridNS\n    psolver::PressureSolver{PolygonNS}\n    msolver::MultiphaseSolver{PolygonNS}\n    E::Float64\n    Simulation() = begin\n        domain = Rectangle(xlims = xlims, ylims = ylims)\n        grid = GridNS(domain, dr)\n        populate_lloyd!(grid, ic! = ic!)\n        return new(grid, PressureSolver(grid), MultiphaseSolver(grid), 0.0)\n    end\nend\n\nfunction step!(sim::Simulation, t::Float64)\n    move!(sim.grid, dt)\n    gravity_step!(sim.grid, -g*VECY, dt)\n    ideal_eos!(sim.grid)\n    find_pressure!(sim.psolver, dt)\n    pressure_step!(sim.grid, dt)\n    find_D!(sim.grid)\n    viscous_step!(sim.grid, dt)\n    find_dv!(sim.grid, dt)\n    multiphase_projection!(sim.msolver) # apply the multiphase solver\n    relaxation_step!(sim.grid, dt)\n    return\nend\n\nfunction postproc!(sim::Simulation, t::Float64)\n    sim.E = 0.0\n    for p in sim.grid.polygons\n        sim.E += p.mass*p.e\n    end\n    percent = round(100*t/t_end, digits = 5)\n    println(\"t = $t ($(percent)%)\")\n    println(\"energy = $(sim.E)\")\n    println()\nend\n\nfunction main()\n    sim = Simulation()\n    run!(sim, dt, t_end, step!,\n        path = export_path,\n        vtp_vars = (:rho, :P, :v, :phase), save_csv = false,\n        postproc! = postproc!,\n        nframes = nframes\n    )\n    return\nend\n\nif abspath(PROGRAM_FILE) == @__FILE__\n    main()\nend\n\nend","category":"page"},{"location":"examples/rayleightaylor.html","page":"Example 5: Rayleigh-Taylor Instability","title":"Example 5: Rayleigh-Taylor Instability","text":"","category":"page"},{"location":"examples/rayleightaylor.html","page":"Example 5: Rayleigh-Taylor Instability","title":"Example 5: Rayleigh-Taylor Instability","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/cavity.html#Example-2:-Lid-driven-cavity","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"","category":"section"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"    <img src='../assets/cavity.png' alt='missing' width=\"50%\" height=\"50%\"><br>","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"Simulation of a vortex induced by viscosity. The domain is a square","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"Omega = 01 times 01","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"with Dirichlet boundary conditions everywhere. The sides and bottom are no-slip condition","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"mathbfv = 0 quad mathbfx in Gamma_mathrmleftcup Gamma_mathrmright cup Gamma_mathrmbottom","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"whereas the top side prescribes a uniform velocity in horizontal direction:","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"mathbfv = beginpmatrix 1  0 endpmatrix quad mathbfx in Gamma_mathrmup","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"The fluid is described by incompressible Navier-Stokes. The solution should be a steady flow, be we can reach it with a dynamic solver by setting sufficiently large t_end. To plot streamlines, open the pvd file in paraview and use the Evenly Spaced Streamlines filter.","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"module cavity\ninclude(\"../src/LagrangianVoronoi.jl\")\nusing .LagrangianVoronoi, DataFrames, CSV, Plots","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"We will use a strictly incompressible model but using the stiffened gas model with large initial sound speed like c0 = 1e3 is also fine.","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"const Re = 100 # Reynolds number\nconst N = 100 # resolution\nconst dr = 1.0/N\nconst dt = min(0.1*dr, 0.1*Re*dr^2)\nconst t_end = 0.1*Re\nconst export_path = \"results/cavity/Re$Re\"\nconst rho0 = 1.0 # fluid density","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"Define the boundary condition for velocity and the initial condition. We must specify the density, mass and the dynamic coefficient of viscosity. To get incompressible fluid, we set the initial sound speed (squared) to plus infinity.","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"function vDirichlet(x::RealVector)::RealVector\n    islid = isapprox(x[2], 1.0, atol = 0.1dr)\n    return islid ? VECX : VEC0\nend\n\nfunction ic!(p::VoronoiPolygon)\n    p.rho = rho0\n    p.mass = p.rho*area(p)\n    p.mu = 1.0/Re\n    p.c2 = Inf\nend\n\nmutable struct Simulation <: SimulationWorkspace\n    grid::GridNS\n    mesh_quality::Float64\n    energy::Float64\n    solver::PressureSolver{PolygonNS}\n    Simulation() = begin\n        domain = UnitRectangle()\n        grid = GridNS(domain, dr)\n        populate_lloyd!(grid, ic! = ic!)\n        return new(grid, 0.0, 0.0, PressureSolver(grid))\n    end\nend","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"When defining the step, we need to activate boundary friction. We omit the equation of state as there is no such thing in the incompressible regime.","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"function step!(sim::Simulation, t::Float64)\n    move!(sim.grid, dt)\n    find_pressure!(sim.solver, dt)\n    pressure_step!(sim.grid, dt)\n    find_D!(sim.grid)\n    viscous_step!(sim.grid, dt; artificial_viscosity = false)\n    bdary_friction!(sim.grid, vDirichlet, dt)\n    find_dv!(sim.grid, dt)\n    relaxation_step!(sim.grid, dt)\n    return\nend\n\nfunction postproc!(sim::Simulation, t::Float64)\n    sim.mesh_quality = Inf\n    for p in sim.grid.polygons\n        sim.energy += 0.5*p.mass*norm_squared(p.v)\n        sim.mesh_quality = min(sim.mesh_quality, p.quality)\n    end\n    percent = round(100*t/t_end, digits = 5)\n    println(\"sim time = $t ($(percent)%)\")\n    println(\"mesh quality = $(sim.mesh_quality)\")\n    println(\"kinetic energy = $(sim.energy)\")\n    println()\n    return\nend","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"Finally, we declare some functions to extract more data. Namely, we measure the horizontal velocity along the vertical axis and vice versa.","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"function compute_fluxes(grid::VoronoiGrid, res = 100)\n    s = range(0.,1.,length=res)\n    v1 = zeros(res)\n    v2 = zeros(res)\n    for i in 1:res\n        #x-velocity along y-centerline\n        x = RealVector(0.5, s[i])\n        v1[i] = point_value(grid, x, p -> p.v[1])\n        #y-velocity along x-centerline\n        x = RealVector(s[i], 0.5)\n        v2[i] = point_value(grid, x, p -> p.v[2])\n    end\n    #save results into csv\n    data = DataFrame(s=s, v1=v1, v2=v2)\n    CSV.write(joinpath(export_path, \"vprofile_legacy.csv\"), data)\n    make_plot()\nend","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"The plot of velocity is compared to a reference solution by Abdelmigid et al.","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"function make_plot()\n    ref_x2vy = CSV.read(\"reference/ldc_x2vy_abdelmigid.csv\", DataFrame)\n    ref_y2vx = CSV.read(\"reference/ldc_y2vx_abdelmigid.csv\", DataFrame)\n    propertyname = Symbol(\"Re\", Re)\n    ref_vy = getproperty(ref_x2vy, propertyname)\n    ref_vx = getproperty(ref_y2vx, propertyname)\n    data = CSV.read(joinpath(export_path, \"vprofile.csv\"), DataFrame)\n    plt = plot(\n        data.s, [movingavg(data.v2) movingavg(data.v1)],\n        xlabel = \"x, y\",\n        ylabel = \"u, v\",\n        label = [\"v\" \"u\"],\n        linewidth = 2,\n        legend = :topleft,\n        color = [:orange :royalblue]\n    )\n    scatter!(plt,\n        [ref_x2vy.x ref_y2vx.y], [ref_vy ref_vx],\n        label = false,\n        color = [:orange :royalblue],\n        markersize = 4,\n        markerstroke = stroke(1, :black),\n        markershape = [:circ :square]\n    )\n    savefig(plt, joinpath(export_path, \"vprofile.pdf\"))\nend","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"Finally, wrap everything into the function main.","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"function main()\n    sim = Simulation()\n    @time run!(\n        sim,\n        dt,\n        t_end,\n        step!;\n        postproc! = postproc!,\n        path = export_path,\n        nframes = 200, # number of time frames\n        vtp_vars = (:v, :P, :quality), # local variables exported in vtk\n        csv_vars = (:energy, :mesh_quality) # global variables exported in csv\n    )\n    compute_fluxes(sim.grid)\n    return\nend\n\nif abspath(PROGRAM_FILE) == @__FILE__\n    main()\nend\n\nend","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"","category":"page"},{"location":"examples/cavity.html","page":"Example 2: Lid-driven cavity","title":"Example 2: Lid-driven cavity","text":"This page was generated using Literate.jl.","category":"page"}]
}
