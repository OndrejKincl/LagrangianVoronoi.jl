include("geometry.jl")

const POLYGON_SIZEHINT = 10
const SIGNUM_EPS = 2*eps(Float64)

const BDARY_UP = -1
const BDARY_RIGHT = -2
const BDARY_DOWN = -3
const BDARY_LEFT = -4

@inline function signum(x::Float64)::Int
    if (x < -SIGNUM_EPS)
        return -1
    elseif (x > SIGNUM_EPS)
        return 1
    end
    return 0
end

"""
    VoronoiPolygon

Abstract supertype for Voronoi Polygons.
We call them Voronoi Polygons and not Voronoi cells to avoid confusion with cells of a cell list.
No functions need to be defined for subtypes of Voronoi Polygon but we require that it has these fields
* `x::RealVector`
* `edges::FastVector{Edge}`
where `x` is the generating seed and edges is a list of all edges in no particular order. The `edges` can be 
initialized as `edges = emptypolygon()` and are generated by the `remesh!` function. 
The subtypes may contain additional fields depending on the physics involved. See `src/celldefs.jl` for examples. 
"""
abstract type VoronoiPolygon end

# initial empty polygon with undefined edges
emptypolygon() = FastVector{Edge}(POLYGON_SIZEHINT)

# Set Voronoi polygon to equal the entire computational domain.
# This is used the initial phase of remeshing. 
@inbounds function reset!(p::VoronoiPolygon, boundary_rect::Rectangle)
    empty!(p.edges)
    A = boundary_rect.xmin
    C = boundary_rect.xmax
    B = RealVector(C[1], A[2])
    D = RealVector(A[1], C[2])
    push!(p.edges, Edge(B, A, label=BDARY_DOWN))
    push!(p.edges, Edge(A, D, label=BDARY_LEFT))
    push!(p.edges, Edge(D, C, label=BDARY_UP))
    push!(p.edges, Edge(C, B, label=BDARY_RIGHT))
end

# Intersects a VoronoiPolygon with the halfplane of all points closer to y than to p.x.
# Use label for newly created edge. This code has very sharp edges, modify with caution.
@inbounds function voronoicut!(p::VoronoiPolygon, y::RealVector, label::Int)::Bool
    diff = y - p.x
    mid = 0.5*(y + p.x)
    c = dot(diff, mid)
    i = 1
    # points of the new edge to be created
    X = VECNULL
    Y = VECNULL
    while (i <= length(p.edges))
        # intersect edge with a halfplane H = {x: f(x) <= 0}
        e = p.edges[i]
        f1 = dot(diff, e.v1) - c
        f2 = dot(diff, e.v2) - c
        s1 = signum(f1)
        s2 = signum(f2)
        s12 = s1 + s2
        # at least one vertex is out:
        if (0 <= s12 <= 1) && (s1|s2 != 0)
            Y = X
            # the intersector of edge end the boundary of H
            X = 1.0/(f1 - f2)*(f1*e.v2 - f2*e.v1)
            # preferably, return one of vertices exactly
            X = (s1 == 0 ? e.v1 : X)
            X = (s2 == 0 ? e.v2 : X)
            # cut the edge
            e_cut = (s1 == 1 ? Edge(X, e.v2, label = e.label) : Edge(e.v1, X, label = e.label))
            p.edges[i] = e_cut
        end
        # delete the edge if it is almost entirely in complement of H 
        if (1 <= s12)
            deleteat!(p.edges, i)
        else
            i += 1
        end
    end
    # if intersected, add the new edge and return true
    if !isnullvector(Y) && (X != Y)
        e = Edge(X, Y, label = label)
        # reorient the edge so it goes counter-clockwise
        if cross2(Y - X, p.x - X) > 0.0
            e = invert(e)
        end 
        push!(p.edges, e)
        return true
    end
    return false
end

# Return the influence radius of a proto-Voronoi Polygon. Beyond this radius it is impossible that 
# a generating seed will produce a neighbor of p. Ergo, this number can be used for pruning the neighbor search in the mesh generation algorithm.
function influence_rr(p::VoronoiPolygon)::Float64
    rr = 0.0
    for e in p.edges
        rr = max(rr, 4.0*norm_squared(e.v1 - p.x))
    end
    return rr
end

"""
    area(p::VoronoiPolygon)::Float64

Return the unoriented area of a polygon.
"""
function area(p::VoronoiPolygon)::Float64
    A = 0.0
    for e in p.edges
        # we need to use abs because the edges may not 
        # have the right orientation
        A += 0.5*abs(cross2(e.v1 - p.x, e.v2 - p.x))
    end
    return A
end

"""
    isboundary(e::Edge)::Bool

Return true iff edge e lies on domain boundary.
"""
function isboundary(e::Edge)::Bool
    return e.label <= 0
end


"""
    isboundary(p::VoronoiPolygon)::Bool

Return true iff the Voronoi Polygon has at least one edge on domain boundary.
"""
function isboundary(p::VoronoiPolygon)::Bool
    for e in p.edges
        if isboundary(e)
            return true
        end
    end
    return false
end

"""
    normal_vector(e::Edge)::RealVector

The vector is rotated by 90% counter-clockwise with respect to the edge `e` pointing from `e.v1` to `e.v2`.
"""
function normal_vector(e::Edge)::RealVector
    @inbounds n = RealVector(e.v1[2]-e.v2[2], e.v2[1]-e.v1[1])
    return n/norm(n)
end

"""
    surface_element(p::VoronoiPolygon)::Float64

The net surface element of a Voronoi Polygon. The resulting vector points outward and is zero for interior polygons.
"""
function surface_element(p::VoronoiPolygon)::Float64
    dS = VEC0
    for e in p.edges
        if isboundary(e)
            @inbounds dS += RealVector(e.v1[2]-e.v2[2], e.v2[1]-e.v1[1])
        end
    end
    return dS
end

"""
    is_inside(p::VoronoiPolygon, x::RealVector)::Bool

Determine whether a point `x` lies inside the polygon `p`.
"""
function is_inside(p::VoronoiPolygon, x::RealVector)::Bool
    # Sunday algorithm
    wn = 0
    @inbounds for e in p.edges
        isleft = (
              (e.v2[1] - e.v1[1])*(x[2] - e.v1[2])
            - (x[1] - e.v1[1])*(e.v2[2] - e.v1[2])
        )
        if (e.v1[2] <= x2 < e.v2[2]) && (isleft > 0.)
            wn += 1
        end
        if (e.v1[2] > x2 >= e.v2[2]) && (isleft < 0.)
            wn -= 1
        end
    end
    return wn != 0
end

"""
    tri_area(a::RealVector, b::RealVector, c::RealVector)::Float64

Return the unsigned area of a triangle given by three points. The points can be in arbitrary order.
"""
function tri_area(a::RealVector, b::RealVector, c::RealVector)::Float64
    return 0.5*abs(LagrangianVoronoi.cross2(b - a, c - a))
end

"""
    centroid(p::VoronoiPolygon)::RealVector

Return the centroid of a Voronoi polygon.
"""
function centroid(p::VoronoiPolygon)::RealVector
    A = 0.0
    c = VEC0
    for e in p.edges
        dA = tri_area(p.x, e.v1, e.v2)
        A += dA
        c += dA*(p.x + e.v1 + e.v2)/3
    end
    return c/A
end

"""
    lr_ratio(dx::RealVector, e::Edge)::Float64

The ratio between the length of a vector `dx` and length of the edge `e`. 
This may sound like a dubious function but is used so very often in this method.
It is slightly faster than `norm(dx)/len(e)` because it computes only one square root.
"""
function lr_ratio(dx::RealVector, e::Edge)::Float64
    l2 = norm_squared(e.v1 - e.v2)
    r2 = norm_squared(dx)
    return sqrt(l2/r2)
end